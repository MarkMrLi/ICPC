## 高精度计算
### 高精度加法
~~~c++
#include <iostream>
#include <string>
using namespace std;
string s1, s2;
int a[10000], b[10000], c[100001];
int main()
{
    //	1.输入值，长度
    cin >> s1 >> s2;
    int len1 = s1.size();
    int len2 = s2.size();
    //	2.把字符转为整数存到数组
    //  注意要个位存到数组开头
    for (int i = 0; i < len1; i++)
    {
        a[i] = s1[len1 - i - 1] - '0';
    }
    for (int i = 0; i < len2; i++)
    {
        b[i] = s2[len2 - i - 1] - '0';
    }
    //	3.获取最大的数。
    int len = max(len1, len2);
    // 对各个位数进行相加
    for (int i = 0; i < len; i++)
    {
        c[i] = a[i] + b[i];
    }
    // 4.进位
    for (int i = 0; i < len; i++)
    {
        c[i + 1] += c[i] / 10;
        c[i] %= 10;
    }
    // 5.溢出
    while (c[len] == 0 && len > 0)
    {
        len--;
    }
    if (c[len] > 0)
    {
        len++;
    }
    // 6.反向输出
    for (int i = len - 1; i >= 0; i--)
    {
        cout << c[i];
    }
    return 0;
}
~~~
### 高精度减法
~~~c++
#include <bits/stdc++.h>
using namespace std;
 
const int MAXN = 1e4+4; //根据题目的最大值。+4为了防止A+B出现进位
char s1[MAXN] = {};//存储字符串
char s2[MAXN] = {};//存储字符串
char tmp[MAXN] = {};//交换用字符串
int a[MAXN] = {};//存储加数A
int b[MAXN] = {};//存储加数B
int c[MAXN] = {};//存储和B
 
int main() {
    scanf("%s %s", s1, s2);
    
    int lena = strlen(s1);
    int lenb = strlen(s2);
    if ((lena<lenb) || (lena==lenb && strcmp(s1,s2)<0)) 
    {
        printf("-");
        strcpy(tmp, s1);
        strcpy(s1, s2);
        strcpy(s2, tmp);
        lena = strlen(s1);
        lenb = strlen(s2);
    }
    
    for (int i=0; i<lena; i++) 
    {
        //倒序写入
        a[i] = s1[lena-i-1] - '0';
    }
 
    for (int i=0; i<lenb; i++) 
    {
        //倒序写入
        b[i] = s2[lenb-i-1] - '0';
    }
 
    for (int i=0; i<lena; i++) 
    {
        if (a[i]<b[i]) 
        {
            //有借位
            a[i+1]--;
            a[i] += 10;
        }
        c[i] = a[i] - b[i];
    }
 
    for (int i=lena-1; i>=0; i--) 
    {
        if (0==c[i] && lena>1) 
        {
            lena--;
        }
        else 
        {
            break;
        }
    }
 
    //逆序打印输出
    for (int i=lena-1; i>=0; i--) 
    {
        printf("%d", c[i]);
    }
    printf("\n");
    
    return 0;
}
~~~

### 高精度乘法
~~~c++
#include <iostream>
using namespace std;
int main(){
	// 大整数 乘 大整数 是 大整数 乘 int 的进阶版 
	string a_s,b_s; //大整数 a 和 b 的字符串形式 
	int a[521]={0},b[521]={0},ans[521*2]={0}; //a, b, ans 的 int数组形式 
	
	int len_a,len_b,len,carry=0,i,j;
	//len_a 为 a 的长度, len_b为 b 的长度, len 为 ans 的长度, carry为进位 
	//切记carry要初始化为 0！！！ 
	
	cin>>a_s>>b_s; //接收两个整数 a, b 
	
	len_a=a_s.length();//分别计算长度 
	len_b=b_s.length();
	
	for(i=0;i<len_a;i++) a[i]=a_s[len_a-1-i]-'0';//分别转为 int 型并倒序存储 
	for(i=0;i<len_b;i++) b[i]=b_s[len_b-1-i]-'0';
	
	for(i=0;i<len_b;i++){ // 核心计算过程,外层循环为乘数, 内层循环为被乘数*int的高精乘低精算法 
		for(j=0;j<len_a||carry!=0;j++){
			ans[i+j]+=a[j]*b[i]+carry; //注意ans的下标为 i+j ! a和 b下标对应它的循环变量 
			carry=ans[i+j]/10;
			ans[i+j]%=10;
		}
	}
	
	len=i+j; //数组最后一个数字为 ans[i+j], 所以 i+j 即为ans长度 
	
	while(ans[len]==0&&len>0) len--; // 去除前缀无用的 0 
	
	for(i=len;i>=0;i--){ //倒序输出 
		cout<<ans[i];
	}
}

~~~

